#include "uart.h"

// 串口初始化程序
void uart_init(void)
{
	// 初始化Tx Rx对应的GPIO引脚
	rGPA0CON &= ~(0xff<<0);			// 把寄存器的bit0～7全部清零
	rGPA0CON |= 0x00000022;			// 0b0010, 把uart_0的两个引脚 Rx Tx，
	
	// 几个关键寄存器的设置
	rULCON0 = 0x3;
	rUCON0 = 0x5;
	rUMCON0 = 0;
	rUFCON0 = 0;
	
	// 波特率设置	DIV_VAL = (PCLK / (bps x 16))-1
	// PCLK_PSYS用66MHz算		余数0.8
	//rUBRDIV0 = 34;	
	//rUDIVSLOT0 = 0xdfdd;
	
	// PCLK_PSYS用66.7MHz算		余数0.18
	// DIV_VAL = (66700000/(115200*16)-1) = 35.18
	rUBRDIV0 = 35;
	// (rUDIVSLOT中的1的个数)/16=上一步计算的余数=0.18
	// (rUDIVSLOT中的1的个数 = 16*0.18= 2.88 = 3
	rUDIVSLOT0 = 0x0888;		// 3个1，查官方推荐表得到这个数字
}


// 串口发送程序，发送一个字节
void putc(char c)
{   
	// 如果发送的有 \n 那么就在前面加一个 '\r' 也就是发送了 '\r\n';
	// 这是由于系统的差异造成的，linux下\n代码回车加换行，而在windows下 \n只是代表
	// 换行而已，'\r\n'才是代表回车加换行！
	if (c == '\n')
	{
		while (!(rUTRSTAT0 & (1<<1)));
		rUTXH0 = '\r';
	}
	// 串口发送一个字符，其实就是把一个字节丢到发送缓冲区中去
	// 因为串口控制器发送1个字节的速度远远低于CPU的速度，所以CPU发送1个字节前必须
	// 确认串口控制器当前缓冲区是空的（意思就是串口已经发完了上一个字节）
	// 如果缓冲区非空则位为0，此时应该循环，直到位为1
	while (!(rUTRSTAT0 & (1<<1)));
	rUTXH0 = c;
}

// 串口接收程序，轮询方式，接收一个字节
char getc(void)
{
	while (!(rUTRSTAT0 & (1<<0)));
	return (rURXH0 & 0xff);
}




//	******** 以下函数仅在shell裸机中使用 *************************
// 串口发送程序，发送一个字节
void shell_putc(char c)
{   
	// 如果发送的有 \n 那么就在前面加一个 '\r' 也就是发送了 '\r\n';
	// 这是由于系统的差异造成的，linux下\n代码回车加换行，而在windows下 \n只是代表
	// 换行而已，'\r\n'才是代表回车加换行！
	if (c == '\n')
	{
		while (!(rUTRSTAT0 & (1<<1)));
		rUTXH0 = '\r';
	}
	// 串口发送一个字符，其实就是把一个字节丢到发送缓冲区中去
	// 因为串口控制器发送1个字节的速度远远低于CPU的速度，所以CPU发送1个字节前必须
	// 确认串口控制器当前缓冲区是空的（意思就是串口已经发完了上一个字节）
	// 如果缓冲区非空则位为0，此时应该循环，直到位为1
	while (!(rUTRSTAT0 & (1<<1)));
	rUTXH0 = c;
}

// 串口接收程序，轮询方式，接收一个字节
char shell_getc(void)
{
	while (!(rUTRSTAT0 & (1<<0)));
	return (rURXH0 & 0xff);
}



// 从stdio输出一个字符串p
void puts(const char *p)	// 参数是一个字符串常量指针 char*p = "aston" 所以类型是匹配的
{
	while (*p != '\0')		// 看到  \0 就跳出，字符串末尾都是反斜杠0，所以看见他就跳出 
	{
		shell_putc(*p);
		p++; 				// 这里++ 大概是字符指针的累加，如果不加，估计会把前面那个替换掉。
	}
}

// 从stdio输入一个字符
char getchar(void)
{
	char c;
// 刚才迷惑了半天，是先接受到 \r\n。但是\r\n不是两个字符。串口接收的先是\r
// 这个时候被if替代成为\n就已经返回了，后面的\n就不会进入了啊。为什么说是\n\n,这样就等于是换了两行
	
	
	c = shell_getc();		// uart_getc() 每次接收一个字节，一个字节也就是一个字符。
	// 假如我们接收了个 l 这里让char c来判断是否是 \r\n ,因为在windows下是这样表示回车的。
	// 如果看见，就返回 \n 给开发板识别。那么 实际输入的参数就是  等于是把\r替换为\n,
	// 那么实际输入给开发板串口的是 \n\n,这样就等于是换了两行。所以接下就去处理这个问题 
	if (c == '\r')
	{
		return '\n';
	}
	
	return c;
}

// 从stdio输入一个字符串
// 返回值指向传进来的数组的首地址的，目的是实现函数的级联调用
char* gets(char *p)
{
	char *p1 = p;
	char ch;
	
	
	// 用户的一次输入是以'\n'为结束标志的，之前getchar中如果按下回车实际输出的是
	// "/n/n" ,但是这里在遇见第一个\n的时候就跳出while，所以没有机会再发出第二个\n
	
	while ((ch = getchar()) != '\n') 	// 这一步判断接收的数据是什么,回车
	{
		// 回显
		if (ch != '\b')
		{
			// 用户输入的不是退格键
			shell_putc(ch);				// 回显
			*p++ = ch;					// 存储ch，等效于 *p = ch; p++;
		}
		else
		{
			// 用户输入的是退格键
			// \b只会让secureCRT终端输出指针向后退一格，但是那个要删掉的字符还在
			// 删掉的方法就是下面3行
			if (p > p1)
			{
				shell_putc('\b');				// 把光标退到前一个字符上
				shell_putc(' ');				// 把这个字符覆盖为空字符
				shell_putc('\b');				// 再把光标退回到这个已经覆盖的控字符上
			// buf中的指针也退一格，然后填充\0。如果这个时候按下回车。那么退出循环后的
			// *p = '\0'只是在这个位置又做了这个'\0'，所以不是两个'\0'
				p--;						// 退一格，指针指向了要删除的那个格子
				*p = '\0';					// 填充'\0'以替换要删除的那个字符
			}	
		}
		
	}
	// 遇到'\n'行结束，添加'\0'作为字符串结尾。
	*p = '\0';
	shell_putc('\n');
	
	return p1;
}








